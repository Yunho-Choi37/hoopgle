import React, { useState, useEffect, useRef } from 'react';
import { supabase } from './supabaseClient';
import SignUpPage from './SignUpPage'; // SignUpPageë¥¼ import í•©ë‹ˆë‹¤.
import './CommunityPage.css';

const CommunityPage = ({ onGoBack, session }) => {
  const [activeChannel, setActiveChannel] = useState('ì•ˆë‚´ì‚¬í•­');
  const [isSidebarOpen, setIsSidebarOpen] = useState(true);
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const [userProfile, setUserProfile] = useState(null);
  const messagesContainerRef = useRef(null);

  // 'login', 'signup', 'success' ë·° ìƒíƒœë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.
  const [authView, setAuthView] = useState('login'); 
  const [authMessage, setAuthMessage] = useState('');
  const [activeReplyInput, setActiveReplyInput] = useState(null);
  const [replyText, setReplyText] = useState('');

  // ë§í¬ ê°ì§€ ë° ì„ë² ë“œ í•¨ìˆ˜ë“¤
  const detectLinks = (text) => {
    const urlRegex = /(https?:\/\/[^\s]+)/g;
    const matches = text.match(urlRegex);
    return matches || [];
  };

  const isYouTubeLink = (url) => {
    return url.includes('youtube.com') || url.includes('youtu.be');
  };

  const isInstagramLink = (url) => {
    return url.includes('instagram.com');
  };

  const getYouTubeEmbedUrl = (url) => {
    let videoId = '';
    if (url.includes('youtube.com/watch?v=')) {
      videoId = url.split('v=')[1].split('&')[0];
    } else if (url.includes('youtu.be/')) {
      videoId = url.split('youtu.be/')[1].split('?')[0];
    }
    return videoId ? `https://www.youtube.com/embed/${videoId}` : null;
  };

  const getInstagramEmbedUrl = (url) => {
    // Instagram oEmbed API ì‚¬ìš©
    return `https://api.instagram.com/oembed/?url=${encodeURIComponent(url)}&hidecaption=true&omitscript=true`;
  };

  // ì›¹ì‚¬ì´íŠ¸ ë©”íƒ€ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (ê°„ë‹¨í•œ ë²„ì „)
  const fetchWebsiteMetadata = async (url) => {
    try {
      // URL ìœ íš¨ì„± ê²€ì‚¬
      if (!url || !url.startsWith('http')) {
        return null;
      }
      
      const urlObj = new URL(url);
      const domain = urlObj.hostname.replace('www.', '');
      const path = urlObj.pathname;
      
      // íŠ¹ì • ì‚¬ì´íŠ¸ë“¤ì— ëŒ€í•œ ê¸°ë³¸ ì •ë³´
      const siteInfo = {
        'sports.naver.com': {
          title: 'ë„¤ì´ë²„ ìŠ¤í¬ì¸ ',
          description: 'ìŠ¤í¬ì¸  ë‰´ìŠ¤ ë° ì‹¤ì‹œê°„ ì •ë³´',
          image: 'https://ssl.pstatic.net/sstatic/keypage/outside/scui/img_og_naver.png',
          siteName: 'ë„¤ì´ë²„ ìŠ¤í¬ì¸ '
        },
        'news.naver.com': {
          title: 'ë„¤ì´ë²„ ë‰´ìŠ¤',
          description: 'ì‹¤ì‹œê°„ ë‰´ìŠ¤ ë° ê¸°ì‚¬',
          image: 'https://ssl.pstatic.net/sstatic/keypage/outside/scui/img_og_naver.png',
          siteName: 'ë„¤ì´ë²„ ë‰´ìŠ¤'
        },
        'blog.naver.com': {
          title: 'ë„¤ì´ë²„ ë¸”ë¡œê·¸',
          description: 'ë¸”ë¡œê·¸ í¬ìŠ¤íŠ¸',
          image: 'https://ssl.pstatic.net/sstatic/keypage/outside/scui/img_og_naver.png',
          siteName: 'ë„¤ì´ë²„ ë¸”ë¡œê·¸'
        },
        'youtube.com': {
          title: 'YouTube',
          description: 'ë™ì˜ìƒ ê³µìœ  í”Œë«í¼',
          image: 'https://www.youtube.com/s/desktop/7c155e84/img/favicon_144x144.png',
          siteName: 'YouTube'
        },
        'youtu.be': {
          title: 'YouTube',
          description: 'ë™ì˜ìƒ ê³µìœ  í”Œë«í¼',
          image: 'https://www.youtube.com/s/desktop/7c155e84/img/favicon_144x144.png',
          siteName: 'YouTube'
        }
      };

      // URLì—ì„œ ì œëª© ì¶”ì¶œ ì‹œë„
      let title = siteInfo[domain]?.title || domain;
      let description = siteInfo[domain]?.description || 'ì›¹í˜ì´ì§€';
      
      // URL ê²½ë¡œì—ì„œ ì œëª© ì¶”ì¶œ
      const pathParts = path.split('/').filter(part => part.length > 0);
      if (pathParts.length > 0) {
        const lastPart = pathParts[pathParts.length - 1];
        if (lastPart && lastPart.length > 5) {
          description = decodeURIComponent(lastPart).replace(/[-_]/g, ' ');
        }
      }

      return {
        title,
        description,
        image: siteInfo[domain]?.image || '',
        siteName: siteInfo[domain]?.siteName || domain,
        url
      };
    } catch (error) {
      console.error('Error processing website metadata:', error);
    }
    return null;
  };

  // ì›¹ì‚¬ì´íŠ¸ ì¹´ë“œ ì»´í¬ë„ŒíŠ¸
  const WebsiteCard = ({ url }) => {
    const [metadata, setMetadata] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(false);

    useEffect(() => {
      const loadMetadata = async () => {
        try {
          setLoading(true);
          const data = await fetchWebsiteMetadata(url);
          if (data) {
            setMetadata(data);
          } else {
            setError(true);
          }
        } catch (err) {
          console.error('Error loading website metadata:', err);
          setError(true);
        } finally {
          setLoading(false);
        }
      };

      // ì¦‰ì‹œ ë¡œë”© ì‹œì‘
      loadMetadata();
      
      // 3ì´ˆ í›„ì—ë„ ë¡œë”©ì´ ì•ˆ ëë‚˜ë©´ ì—ëŸ¬ë¡œ ì²˜ë¦¬
      const timeout = setTimeout(() => {
        if (loading) {
          setError(true);
          setLoading(false);
        }
      }, 3000);

      return () => clearTimeout(timeout);
    }, [url]);



    if (loading) {
      return (
        <div className="link-embed website-card loading">
          <div className="card-skeleton">
            <div className="skeleton-image"></div>
            <div className="skeleton-content">
              <div className="skeleton-title"></div>
              <div className="skeleton-description"></div>
              <div className="skeleton-url"></div>
            </div>
          </div>
        </div>
      );
    }

    if (error || !metadata) {
      // ë©”íƒ€ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ì„ ë•Œ ê¸°ë³¸ ë§í¬ ì¹´ë“œ í‘œì‹œ
      try {
        const urlObj = new URL(url);
        const domain = urlObj.hostname.replace('www.', '');
        const path = urlObj.pathname;
        
        return (
          <div className="link-embed website-card fallback">
            <a href={url} target="_blank" rel="noopener noreferrer" className="website-card-link">
              <div className="website-card-content">
                <h4 className="website-card-title">ğŸ”— {domain}</h4>
                <p className="website-card-description">{path}</p>
                <div className="website-card-meta">
                  <span className="website-card-site">{domain}</span>
                  <span className="website-card-url">{url}</span>
                </div>
              </div>
            </a>
          </div>
        );
      } catch (urlError) {
        // URLì´ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°
        return (
          <div className="link-embed website-card error">
            <a href={url} target="_blank" rel="noopener noreferrer" className="link-url">
              ğŸ”— {url}
            </a>
          </div>
        );
      }
    }
      
      return (
        <div className="link-embed website-card fallback">
          <a href={url} target="_blank" rel="noopener noreferrer" className="website-card-link">
            <div className="website-card-content">
              <h4 className="website-card-title">ğŸ”— {domain}</h4>
              <p className="website-card-description">{path}</p>
              <div className="website-card-meta">
                <span className="website-card-site">{domain}</span>
                <span className="website-card-url">{url}</span>
              </div>
            </div>
          </a>
        </div>
      );
    }

    return (
      <div className="link-embed website-card">
        <a href={url} target="_blank" rel="noopener noreferrer" className="website-card-link">
          {metadata.image && (
            <div className="website-card-image">
              <img src={metadata.image} alt={metadata.title} />
            </div>
          )}
          <div className="website-card-content">
            <h4 className="website-card-title">{metadata.title}</h4>
            {metadata.description && (
              <p className="website-card-description">{metadata.description}</p>
            )}
            <div className="website-card-meta">
              <span className="website-card-site">{metadata.siteName}</span>
              <span className="website-card-url">{new URL(url).hostname}</span>
            </div>
          </div>
        </a>
      </div>
    );
  };

  const renderMessageContent = (content) => {
    const links = detectLinks(content);
    if (links.length === 0) {
      return <p className="message-text">{content}</p>;
    }

    let processedContent = content;
    const embeds = [];

    links.forEach((link, index) => {
      const linkId = `link-${index}`;
      processedContent = processedContent.replace(link, `[${linkId}]`);
      
      if (isYouTubeLink(link)) {
        const embedUrl = getYouTubeEmbedUrl(link);
        if (embedUrl) {
          embeds.push(
            <div key={linkId} className="link-embed youtube-embed">
              <iframe
                width="100%"
                height="200"
                src={embedUrl}
                title="YouTube video"
                frameBorder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                allowFullScreen
              ></iframe>
              <a href={link} target="_blank" rel="noopener noreferrer" className="link-url">
                {link}
              </a>
            </div>
          );
        }
      } else if (isInstagramLink(link)) {
        embeds.push(
          <div key={linkId} className="link-embed instagram-embed">
            <iframe
              src={`https://www.instagram.com/p/${link.split('/p/')[1]?.split('/')[0]}/embed`}
              width="100%"
              height="400"
              frameBorder="0"
              scrolling="no"
              allowTransparency={true}
            ></iframe>
            <a href={link} target="_blank" rel="noopener noreferrer" className="link-url">
              {link}
            </a>
          </div>
        );
      } else {
        // ì¼ë°˜ ì›¹ì‚¬ì´íŠ¸ ë§í¬ - ë©”íƒ€ë°ì´í„° ì¹´ë“œë¡œ í‘œì‹œ
        embeds.push(
          <WebsiteCard key={linkId} url={link} />
        );
      }
    });

    return (
      <>
        <p className="message-text">{processedContent}</p>
        {embeds}
      </>
    );
  };

  useEffect(() => {
    if (messagesContainerRef.current) {
      messagesContainerRef.current.scrollTop = messagesContainerRef.current.scrollHeight;
    }
  }, [messages]);

  useEffect(() => {
    const fetchUserProfile = async () => {
      if (session?.user) {
        console.log('Fetching profile for user:', session.user.id);
        const { data, error } = await supabase
          .from('profiles')
          .select('username, avatar_url')
          .eq('id', session.user.id)
          .single();

        if (error) {
          console.error('Error fetching user profile:', error);
          // í”„ë¡œí•„ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ì„¤ì •
          setUserProfile({
            username: session.user.user_metadata?.username || session.user.email?.split('@')[0] || 'ì‚¬ìš©ì',
            avatar_url: '/default-avatar.png'
          });
        } else {
          console.log('User profile loaded:', data);
          setUserProfile(data);
        }
      }
    };
    fetchUserProfile();
  }, [session]);

  const fetchMessages = async () => {
    if (activeChannel === 'ì•ˆë‚´ì‚¬í•­') {
      setMessages([]);
      return;
    }
    console.log('Fetching messages for channel:', activeChannel);
    const { data, error } = await supabase
      .from('messages')
      .select(`*,
        profiles(username, avatar_url)
      `)
      .eq('channel', activeChannel)
      .order('created_at', { ascending: true });

    if (error) {
      console.error('Error fetching messages:', error);
    } else {
      console.log('Fetched messages:', data);
      
      // ê° ë©”ì‹œì§€ì˜ ì‚¬ìš©ì í”„ë¡œí•„, ë°˜ì‘, ëŒ“ê¸€ì„ ê°€ì ¸ì˜¤ê¸°
      const messagesWithProfiles = await Promise.all(
        data.map(async (message) => {
          // í”„ë¡œí•„ ê°€ì ¸ì˜¤ê¸°
          const { data: profileData, error: profileError } = await supabase
            .from('profiles')
            .select('username, avatar_url')
            .eq('id', message.user_id)
            .single();
          
          console.log('Message profile fetch result:', { profileData, profileError, userId: message.user_id });
          
          // ë°˜ì‘ ê°€ì ¸ì˜¤ê¸°
          const { data: reactionsData } = await supabase
            .from('message_reactions')
            .select('reaction_type')
            .eq('message_id', message.id);
          
                      // ëŒ“ê¸€ ê°€ì ¸ì˜¤ê¸°
            const { data: repliesData, error: repliesError } = await supabase
              .from('message_replies')
              .select('*')
              .eq('message_id', message.id)
              .order('created_at', { ascending: true });
            
            if (repliesError) {
              console.error('Error fetching replies:', repliesError);
            }
            
            // ëŒ“ê¸€ì˜ ì‚¬ìš©ì í”„ë¡œí•„ì„ ë³„ë„ë¡œ ê°€ì ¸ì˜¤ê¸°
            let repliesWithProfiles = [];
            if (repliesData && repliesData.length > 0) {
              repliesWithProfiles = await Promise.all(
                repliesData.map(async (reply) => {
                  const { data: replyProfileData, error: replyProfileError } = await supabase
                    .from('profiles')
                    .select('username, avatar_url')
                    .eq('id', reply.user_id)
                    .single();
                  
                  if (replyProfileError) {
                    console.error('Error fetching reply profile:', replyProfileError);
                    return {
                      ...reply,
                      profiles: {
                        username: `ì‚¬ìš©ì_${reply.user_id.slice(0, 8)}`,
                        avatar_url: '/default-avatar.png'
                      }
                    };
                  }
                  
                  return {
                    ...reply,
                    profiles: replyProfileData
                  };
                })
              );
            }
          
          // ë°˜ì‘ ê°œìˆ˜ ê³„ì‚°
          const likes = reactionsData?.filter(r => r.reaction_type === 'like').length || 0;
          const laughs = reactionsData?.filter(r => r.reaction_type === 'laugh').length || 0;
          const cries = reactionsData?.filter(r => r.reaction_type === 'cry').length || 0;
          
          if (profileError) {
            console.error('Error fetching profile for user:', message.user_id, profileError);
            // í”„ë¡œí•„ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ì„¤ì •
            return {
              ...message,
              profiles: {
                username: `ì‚¬ìš©ì_${message.user_id.slice(0, 8)}`,
                avatar_url: '/default-avatar.png'
              },
              likes,
              laughs,
              cries,
              replies: repliesWithProfiles || []
            };
          }
            
            const finalMessage = {
              ...message,
              profiles: profileData,
              likes,
              laughs,
              cries,
              replies: repliesWithProfiles || []
            };
            
            console.log('Final message with profile:', {
              messageId: message.id,
              username: finalMessage.profiles?.username,
              userId: message.user_id
            });
            
            return finalMessage;
        })
      );
      
      setMessages(messagesWithProfiles);
    }
  };

  useEffect(() => {
    fetchMessages();

    const messageSubscription = supabase
      .channel(`messages-for-${activeChannel}`)
      .on(
        'postgres_changes',
        { event: 'INSERT', schema: 'public', table: 'messages', filter: `channel=eq.${activeChannel}` },
        (payload) => {
          fetchMessages();
        }
      )
      .subscribe((status) => {
        if (status === 'SUBSCRIBED') {
          console.log(`Successfully subscribed to ${activeChannel}`);
        }
        if (status === 'CHANNEL_ERROR') {
          console.error(`Failed to subscribe to ${activeChannel}`);
        }
      });

    return () => {
      supabase.removeChannel(messageSubscription);
    };
  }, [activeChannel]);

  const toggleSidebar = () => {
    setIsSidebarOpen(!isSidebarOpen);
  };

  const handleSendMessage = async () => {
    if (newMessage.trim() === '' || !session?.user) return;

    const optimisticMessage = {
      id: Math.random(),
      content: newMessage,
      created_at: new Date().toISOString(),
      user_id: session.user.id,
      channel: activeChannel,
      profiles: userProfile || {
        username: session.user.user_metadata?.username || session.user.email?.split('@')[0] || 'ì‚¬ìš©ì',
        avatar_url: '/default-avatar.png'
      },
    };

    setMessages(currentMessages => [...currentMessages, optimisticMessage]);

    const messageToSend = newMessage;
    setNewMessage('');

    const { error } = await supabase
      .from('messages')
      .insert({
        content: messageToSend,
        user_id: session.user.id,
        channel: activeChannel,
      });

    if (error) {
      console.error('Error sending message:', error);
      setMessages(currentMessages => currentMessages.filter(m => m.id !== optimisticMessage.id));
      setNewMessage(messageToSend);
    }
  };

  const handleSignIn = async () => {
    setLoading(true);
    setAuthMessage('');
    const { data, error } = await supabase.auth.signInWithPassword({ email, password });
    if (error) {
      setAuthMessage(error.error_description || error.message);
    } else if (data.user) {
      console.log('Login successful, user data:', data.user);
      // ë¡œê·¸ì¸ ì„±ê³µ í›„ í”„ë¡œí•„ í™•ì¸ ë° ìƒì„±
      const { data: profileData, error: profileError } = await supabase
        .from('profiles')
        .select('username, avatar_url')
        .eq('id', data.user.id)
        .single();
      
      console.log('Profile check result:', { profileData, profileError });
      
      if (profileError && profileError.code === 'PGRST116') {
        // í”„ë¡œí•„ì´ ì—†ìœ¼ë©´ ìƒì„±
        const username = data.user.user_metadata?.username || data.user.email?.split('@')[0] || 'ì‚¬ìš©ì';
        console.log('Creating profile with username:', username);
        
        const { data: insertData, error: insertError } = await supabase
          .from('profiles')
          .insert([
            {
              id: data.user.id,
              username: username,
              email: data.user.email,
              avatar_url: '/default-avatar.png'
            }
          ])
          .select();
        
        if (insertError) {
          console.error('Error creating profile:', insertError);
        } else {
          console.log('Profile created successfully:', insertData);
        }
      }
    }
    setLoading(false);
  };

  const handleSignOut = async () => {
    setLoading(true);
    await supabase.auth.signOut();
    setLoading(false);
    setUserProfile(null);
    setAuthView('login');
  };

  const handleReaction = async (messageId, reactionType) => {
    console.log('handleReaction called with:', { messageId, reactionType, userId: session?.user?.id });
    
    if (!session?.user) {
      console.log('No user session');
      return;
    }

    try {
      console.log('Attempting to upsert reaction:', {
        message_id: messageId,
        user_id: session.user.id,
        reaction_type: reactionType
      });
      
      const { data, error } = await supabase
        .from('message_reactions')
        .upsert({
          message_id: messageId,
          user_id: session.user.id,
          reaction_type: reactionType
        })
        .select();

      if (error) {
        console.error('Error adding reaction:', error);
        alert('ë°˜ì‘ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
      } else {
        console.log('Reaction saved successfully:', data);
        // ë©”ì‹œì§€ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
        fetchMessages();
      }
    } catch (error) {
      console.error('Error handling reaction:', error);
      alert('ë°˜ì‘ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
    }
  };

  const toggleReplyInput = (messageId) => {
    if (activeReplyInput === messageId) {
      setActiveReplyInput(null);
      setReplyText('');
    } else {
      setActiveReplyInput(messageId);
      setReplyText('');
    }
  };

  const handleSendReply = async (messageId) => {
    console.log('handleSendReply called with:', { messageId, replyText, userId: session?.user?.id });
    
    if (!replyText.trim()) {
      console.log('Reply text is empty');
      return;
    }
    
    if (!session?.user) {
      console.log('No user session');
      return;
    }

    try {
      console.log('Attempting to insert reply:', {
        message_id: messageId,
        user_id: session.user.id,
        content: replyText.trim()
      });
      
      const { data, error } = await supabase
        .from('message_replies')
        .insert({
          message_id: messageId,
          user_id: session.user.id,
          content: replyText.trim()
        })
        .select();

      if (error) {
        console.error('Error sending reply:', error);
        alert('ëŒ“ê¸€ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
      } else {
        console.log('Reply saved successfully:', data);
        setReplyText('');
        setActiveReplyInput(null);
        // ë©”ì‹œì§€ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
        fetchMessages();
      }
    } catch (error) {
      console.error('Error sending reply:', error);
      alert('ëŒ“ê¸€ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
    }
  };

  const renderAuth = () => {
    if (authView === 'signup') {
      return (
        <SignUpPage 
          onSignUpSuccess={() => {
            setAuthMessage('ê°€ì… í™•ì¸ì„ ìœ„í•´ ì´ë©”ì¼ì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
            setAuthView('login');
          }}
          onBackToLogin={() => setAuthView('login')}
        />
      );
    }

    return (
      <div className="login-prompt">
        <h3>ì±„íŒ…ì— ì°¸ì—¬í•˜ë ¤ë©´ ë¡œê·¸ì¸í•˜ì„¸ìš”</h3>
        {authMessage && <p className="auth-message">{authMessage}</p>}
        <input
          type="email"
          placeholder="ì´ë©”ì¼"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
        <input
          type="password"
          placeholder="ë¹„ë°€ë²ˆí˜¸"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />
        <div className="login-buttons">
          <button onClick={handleSignIn} disabled={loading}>
            {loading ? 'ë¡œê·¸ì¸ ì¤‘...' : 'ë¡œê·¸ì¸'}
          </button>
          <button onClick={() => { setAuthView('signup'); setAuthMessage(''); }} disabled={loading}>
            íšŒì›ê°€ì…
          </button>
        </div>
      </div>
    );
  };

  const renderContent = () => {
    // ì•ˆë‚´ì‚¬í•­ ì±„ë„ì€ í•­ìƒ ë™ì¼í•œ ë‚´ìš©ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.
    if (activeChannel === 'ì•ˆë‚´ì‚¬í•­') {
      return (
        <>
          <div className="message-item">
            <span className="message-author">ìš´ì˜ì</span>
            <p>Hoop Zoneì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤! ì»¤ë®¤ë‹ˆí‹° ê·œì¹™ì„ ì˜ ì§€ì¼œì£¼ì„¸ìš”.</p>
          </div>
          <div className="message-item">
            <span className="message-author">ìš´ì˜ì</span>
            <p>ì„ ìˆ˜ ë¹„ë°©ì´ë‚˜ ìš•ì„¤ì€ ê²½ê³  ì—†ì´ ì‚­ì œë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
          </div>
        </>
      );
    }
    // ë‹¤ë¥¸ ì±„ë„ì˜ ë©”ì‹œì§€ë¥¼ ë Œë”ë§í•©ë‹ˆë‹¤.
    return (
      <div className="messages-list-content">
        {messages.length === 0 ? (
          <p className="no-messages">ë©”ì‹œì§€ê°€ ì—†ìŠµë‹ˆë‹¤. ì²« ë©”ì‹œì§€ë¥¼ ë‚¨ê²¨ë³´ì„¸ìš”!</p>
        ) : (
          messages.map((msg) => (
            <div key={msg.id} className="message-item">
              <div className="message-content-wrapper">
                <span className="message-author">
                  {msg.profiles?.username || `ì‚¬ìš©ì_${msg.user_id?.slice(0, 8)}`}
                </span>
                {renderMessageContent(msg.content)}
                <div className="message-actions">
                  <button className="reaction-btn" onClick={() => handleReaction(msg.id, 'like')}>
                    ğŸ‘ <span className="reaction-count">{msg.likes || 0}</span>
                  </button>
                  <button className="reaction-btn" onClick={() => handleReaction(msg.id, 'laugh')}>
                    ğŸ˜‚ <span className="reaction-count">{msg.laughs || 0}</span>
                  </button>
                  <button className="reaction-btn" onClick={() => handleReaction(msg.id, 'cry')}>
                    ğŸ˜¢ <span className="reaction-count">{msg.cries || 0}</span>
                  </button>
                  <button className="reply-btn" onClick={() => toggleReplyInput(msg.id)}>
                    ğŸ’¬ ëŒ“ê¸€
                  </button>
                </div>
                <span className="message-timestamp">{new Date(msg.created_at).toLocaleString()}</span>
                
                {/* ëŒ“ê¸€ ì…ë ¥ì°½ */}
                {activeReplyInput === msg.id && (
                  <div className="reply-input-container">
                    <input
                      type="text"
                      placeholder="ëŒ“ê¸€ì„ ì…ë ¥í•˜ì„¸ìš”..."
                      value={replyText}
                      onChange={(e) => setReplyText(e.target.value)}
                      onKeyPress={(e) => { if (e.key === 'Enter') handleSendReply(msg.id); }}
                    />
                    <button onClick={() => handleSendReply(msg.id)}>ì „ì†¡</button>
                    <button onClick={() => setActiveReplyInput(null)}>ì·¨ì†Œ</button>
                  </div>
                )}
                
                {/* ëŒ“ê¸€ ëª©ë¡ */}
                {msg.replies && msg.replies.length > 0 && (
                  <div className="replies-container">
                    {msg.replies.map((reply) => (
                      <div key={reply.id} className="reply-item">
                        <div className="reply-content">
                          <span className="reply-author">{reply.profiles?.username || `ì‚¬ìš©ì_${reply.user_id?.slice(0, 8)}`}</span>
                          <div className="reply-text-wrapper">
                            {renderMessageContent(reply.content)}
                          </div>
                        </div>
                        <span className="reply-timestamp">{new Date(reply.created_at).toLocaleString()}</span>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </div>
          ))
        )}
      </div>
    );
  };

  return (
    <div className="community-page">
      <div className={`channels-sidebar ${isSidebarOpen ? 'open' : 'closed'}`}>
        <div className="channels-header">
          <h3 className="logo-small">
            <span className="hoopgle-red">H</span><span className="hoopgle-yellow">o</span><span className="hoopgle-navy">o</span><span className="hoopgle-yellow">p</span> <span className="hoopgle-navy">Z</span><span className="hoopgle-yellow">o</span><span className="hoopgle-navy">n</span><span className="hoopgle-yellow">e</span>
          </h3>
        </div>
        <ul className="channel-list">
          <li className={`channel-item ${activeChannel === 'ì•ˆë‚´ì‚¬í•­' ? 'active' : ''}`} onClick={() => setActiveChannel('ì•ˆë‚´ì‚¬í•­')}>ğŸ“¢ ì•ˆë‚´ì‚¬í•­</li>
          <li className={`channel-item ${activeChannel === 'ììœ ì±„íŒ…' ? 'active' : ''}`} onClick={() => setActiveChannel('ììœ ì±„íŒ…')}>ğŸ’¬ ììœ ì±„íŒ…</li>
          <li className={`channel-item ${activeChannel === 'ë°ì¼ë¦¬í›•' ? 'active' : ''}`} onClick={() => setActiveChannel('ë°ì¼ë¦¬í›•')}>ğŸ”¥ ë°ì¼ë¦¬í›•</li>
        </ul>
        {session && (
          <div className="profile-section">
            <span className="profile-name">
              {userProfile?.username || session.user.user_metadata?.username || session.user.email?.split('@')[0] || 'ì‚¬ìš©ì'}
            </span>
            <button onClick={handleSignOut} className="signout-button" disabled={loading}>
              {loading ? 'ë¡œê·¸ì•„ì›ƒ ì¤‘...' : 'ë¡œê·¸ì•„ì›ƒ'}
            </button>
          </div>
        )}
      </div>
      <div className={`chat-area ${!isSidebarOpen ? 'sidebar-closed' : ''}`}>
        <div className="chat-header">
          <div className="chat-header-left">
            <h3>{activeChannel}</h3>
          </div>
          <div className="chat-header-right">
            <button onClick={onGoBack} className="back-button-community">í™ˆìœ¼ë¡œ</button>
          </div>
        </div>
        
        {/* ì‚¬ì´ë“œë°” í† ê¸€ ë²„íŠ¼ - ë…¸ì…˜ ìŠ¤íƒ€ì¼ */}
        <button 
          onClick={toggleSidebar} 
          className={`sidebar-toggle-button ${isSidebarOpen ? 'open' : 'closed'}`}
          title={isSidebarOpen ? 'ì‚¬ì´ë“œë°” ìˆ¨ê¸°ê¸°' : 'ì‚¬ì´ë“œë°” ë³´ì´ê¸°'}
        >
          <div className="toggle-icon">
            <span></span>
            <span></span>
            <span></span>
          </div>
        </button>
        <div className="messages-list" ref={messagesContainerRef}>
          {renderContent()}
        </div>
        {activeChannel !== 'ì•ˆë‚´ì‚¬í•­' && (
          <div className="chat-input-box">
            {session ? (
              <>
                <input
                  type="text"
                  placeholder={`${activeChannel}ì— ë©”ì‹œì§€ ë³´ë‚´ê¸°`}
                  value={newMessage}
                  onChange={(e) => setNewMessage(e.target.value)}
                  onKeyPress={(e) => { if (e.key === 'Enter') handleSendMessage(); }}
                />
                <button onClick={handleSendMessage}>ì „ì†¡</button>
              </>
            ) : (
              renderAuth()
            )}
          </div>
        )}
      </div>
    </div>
  );
};

export default CommunityPage;
